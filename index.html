<!DOCTYPE html>
<html>
<head>
<style>

body{
text-align:center;
}
code {
  font-family: Consolas,"courier new";
  color: crimson;
  padding: 2px;
  font-size: 15px;

}

p{
  font-size: 15px;
  color:black;
}

.container{
 display: flex;
 flex-direction:column;
    align-items: center;
    margin: 0 0 2rem;
    padding: 1rem 2rem;
    background: #fff;
    min-width: 250px;
    border-radius: .75rem;
    box-shadow: 0 0.5rem 1.5rem #edf0f7;
    border: 1px solid #edf0f7;
}
ul{
list-style-type:none;
}
</style>
</head>
<body>

<h1>Java Basics -  Refer during practice</h1>

<p>DataTypes</p>
<ul>
<li><code>int myNum = 5; </code>              // Integer (whole number)</li>
<li><code>float myFloatNum = 5.99f;</code>    // Floating point number</li>
<li><code>char myLetter = 'D';</code>         // Character</li>
<li><code>boolean myBool = true; </code>      // Boolean</li></li>
<li><code>String myText = "Hello";</code>     // String</li>

</ul>
<div class="container">
<h3>Array</h3>

<code>dataType [] VarName = new dataType[arraySize];</code>
<p>Methods</p>
<p><code>Array.length - get size of array<p></code>
<code>int[] array = {23, 43, 55, 12};<br>
int[] copiedArray = array.clone();</code>
</div>

<div class="container">
<h3>String</h3>
<code>String txt = "Hello World";</code>
<p>Methods</p>
<p>The <b>indexOf()</b> method returns the index (the position) of the first occurrence of a specified text in a string (including whitespace):
</p>
<code>txt.indexOf("hello")</code>
<p><b>concatenate</b> two strings:</p>
<code>string1.concat(string2)</code>
<p><b>charAt()</b>:- Returns the character at the specified index (position)</p>
<code>txt.charAt(0); // H</code>
<p>Checks whether a string contains a <b>sequence of characters</b></p>
<code>txt.contains("Hel") // true</code>
<p>The <b>length()</b> method returns the length of a specified string <b>including white spaces</b></p>
<code>txt.length()</code>
<p><b>substring</b> Extracts the characters from a string, beginning at a specified start position, and through the specified number of character
<b>beginIndex is inclusive and endIndex is exclusive</b>
</p>
<code>String substring(int beginIndex, int endIndex)</code>
</div>


<div class="container">
<h3>2DArray</h3>
<code>dataType[][] arr = new dataType[row][column];</code> 



</div>
<div class="container">
<h3>ArrayList</h3>
<code> ArrayList <> ListName = new ArrayList <>();</code>
<p>Methods</p>
<p><code>void add(int index, E element)</code></p>
<p><code>get(int index)</p></code>
<p><code>contains(Object o)</p></code>
<p><code>remove(int index)</p></code>
</div>
<div class="container">
<h3>HashMap</h3>
<code>HashMap <>, <> key = new HashMap <>, <>();</code>
<p>Methods</p>
<p><code>containsKey(key_element)</code></p>
<p><code>containsValue(key_element)</code></p>
<p><code>put(Object key, Object value)</code></p>
<p><code>int size()</code></p>
<p><code>get(Object key)</code></p>
<p><code>remove(Object key)</code></p>
</div>

<div class="container">
<h3>Stack</h3>
<code>Stack<Integer> stack = new Stack<Integer>();</code>
<p>Methods</p>
<p>To add a value to the top of the stack:</p>
<p><code>stack.push(1) OR stack.push("hello")</code> </p>

<p>To return and remove a value from the top:</p>
<p><code>String top = stack.pop();</code></p></code>

<p>To return a value without removing it:</p>
<p><code>String peek = stack.peek();</code></p>
<p>True if stack is empty</p>
<p><code>stack.empty();</code></p>
<p>Get size of stack</p>
<code> int size = stack.size(); </code>

</div>
<div class="container">
<h3>Queue</h3>
<code>Queue<> q = new LinkedList<>();</code>
<p>To add a value to the back of queue:</p>
<code>queue.add(7);</code>

<p>To remove and return front value:</p>
<code>int next = queue.remove();</code>

<p>To just return front value without removing:</p>
<code>int peek = queue.peek();</code>
<p>Get size of queue</p>
<code> int size = q.size(); </code>

</div>

<div class="container">


<code>Inorder (Left, Root, Right)</code>
<code>Preorder (Root, Left, Right)</code>
<code>Postorder (Left, Right, Root)</code>
<h4>BFS Algorithm</h4>
<code>
function breadthFirstSearch (Start, Goal)<br>
   {    <br>
       enqueue(Queue,Start)<br>
       setVisited(start)<br>
       while notEmpty(Queue)<br>
       {<br>
           Node := dequeue(Queue)<br>
           if Node = Goal<br>
           {<br>
               return Node<br>
           }<br>
           for each Child in Expand(Node)<br>
           {<br>
               if notVisited(Child)<br>
               {     <br>         
                   setVisited(Child)<br>
                   enqueue(Queue, Child)<br>
               }<br>
           }<br>
       }<br>
   }<br>




</code>
<h4>DFS</h4>
<p>
 Algorithm<br>

 1) Pick any node. <br>
 2) If it is unvisited, mark it as visited and recur on all its <br>
    adjacent nodes. <br>
 3) Repeat until all the nodes are visited, or the node to be <br>
    searched is found.

<p>
</div>
<div>
<h3>Time Complexity</h3>

<img src="https://raw.githubusercontent.com/kaddy645/Jref.github.io/gh-pages/sortingScreenshot.png" alt="sorting alogorithm complexsity" >

<img src="https://raw.githubusercontent.com/kaddy645/Jref.github.io/gh-pages/dataStructures.png" alt="sorting alogorithm complexsity" >

</div>
</div>
</body>
</html>
